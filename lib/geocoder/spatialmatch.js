'use strict';
const proximity = require('../util/proximity.js');
const stackAndCoalesce = require('@mapbox/carmen-core').stackAndCoalesce;
const bbox = require('../util/bbox.js');
const roundTo = require('../util/round-to.js');
const termops = require('../text-processing/termops');

module.exports = spatialmatch;
// module.exports.rebalance = rebalance;

/**
 * spatialmatch determines whether indexes can be spatially stacked and discards indexes that cannot be stacked together
 *
 * @access public
 *
 * @param {Array} query a list of terms composing the query to Carmen
 * @param {Array} phrasematchResults for subquery permutations generated by ./lib/phrasematch
 * @param {Object} options passed in with the query
 * @param {function} callback callback called with indexes that could be spatially stacked
 */
function spatialmatch(query, phrasematchResults, options, callback) {
    if (!phrasematchResults.length) return done(null, []);

    const preparedPhrasematches = preparePhrasematches(phrasematchResults);

    const coalesceOpts = {};
    coalesceOpts.zoom = preparedPhrasematches.maxZoom;
    if (options) {
        if (options.proximity) {
            coalesceOpts.proximity = proximity.center2zxy(
                options.proximity,
                coalesceOpts.zoom
            ).slice(1);
        }

        if (options.bbox) {
            coalesceOpts.bbox = bbox.insideTile(options.bbox, preparedPhrasematches.maxZoom).slice(1);
        }
    }

    stackAndCoalesce(preparedPhrasematches.flattenedPhrasematches, coalesceOpts, done);

    function done(err, results) {
        if (err) return callback(err);
        results = results || [];
        const combined = results.map((result) => new Spatialmatch(rebalance_new(query, result, preparedPhrasematches.flattenedPhrasematches), preparedPhrasematches.flattenedPhrasematches));
        combined.sort(sortByRelev);

        // Ascending and Descending order here refers to being able to support
        // `address, place, region, country` and `country, region, place, address`
        // Also supports being able to return a single feature that hasn't been
        // stacked with another index
        const sets = {};
        const doneAscending = {};
        const doneDescending = {};
        const doneSingle = {};
        const filteredSpatialmatches = [];
        for (let i = 0; i < combined.length; i++) {
            const spatialmatch = combined[i];
            const covers = spatialmatch.covers;
            for (let j = 0; j < covers.length; j++) {
                const id = covers[j].tmpid;
                if (!sets[id] || sets[id].relev < covers[j].relev) {
                    sets[id] = covers[j];
                }
            }

            const tmpid = covers[0].tmpid;
            // only allow one result in each direction
            if (covers.length > 1 && covers[0].idx > covers[1].idx && !doneDescending[tmpid]) {
                doneDescending[tmpid] = true;
                filteredSpatialmatches.push(spatialmatch);
            } else if (covers.length > 1 && covers[0].idx < covers[1].idx && !doneAscending[tmpid]) {
                doneAscending[tmpid] = true;
                filteredSpatialmatches.push(spatialmatch);
            } else if (covers.length === 1 && !doneAscending[tmpid] && !doneDescending[tmpid] && !doneSingle[tmpid]) {
                doneSingle[tmpid] = true;
                filteredSpatialmatches.push(spatialmatch);
            }
        }
        return callback(null, { results: filteredSpatialmatches, sets: sets, waste: [] });
    }
}

/**
 * rebalance recalculates the relevance based on the number of tokens and number of layers that match in the result and query
 *
 * Rebalancing is done to prevent cases where the number of tokens causes the relevance to cause an index to win
 * over an index that actually has the feature
 * For example: Martin Luther King Jr. Street, Thanjavur, Tamil Nadu would return an American city
 * since Martin Luther King Jr. Street is a really long street name
 * any result that contains the street(like Martin Luther King Jr. Street, Washington, DC would automatically have a higher relevance.
 *
 * @param {Array} query a list of terms composing the query to Carmen
 * @param {Array} stack results for a subquery combination
 * @returns {Array} - rebalanced stack
 */
// function rebalance(query, stack, flattenedPhrasematches) {
//     let stackMask = 0;
//     const stackClone = Object.assign({}, stack);
//
//     for (let i = 0; i < stack.entries.length; i++) {
//         stackMask |= stack.entries[i].mask;
//     }
//
//     const garbage = (query.length === (stackMask.toString(2).split(1).length - 1)) ? 0 : 1;
//     const totalLengthBonus = .01 * (garbage + stack.entries.length);
//     const weightPerMatch = (1 / (garbage + stack.entries.length)) - 0.01;
//
//     // shallow copy stack into stackClone to prevent cases where a stack's
//     // index gets overwritten in deep copies.
//     let totalWeight = 0;
//     for (let k = 0; k < stack.entries.length; k++) {
//         const entry = stack.entries[k];
//         const phrasematch = flattenedPhrasematches[entry.phrasematch_id];
//         if (stack.entries[k].grid_entry.relev < phrasematch.weight) {
//             stackClone.entries[k].grid_entry.relev = stack.entries[k].grid_entry.relev;
//             continue;
//         }
//         stackClone.entries[k].grid_entry.relev = roundTo(
//             weightPerMatch +
//             (totalLengthBonus * stack.entries[k].grid_entry.relev)
//             , 8);
//         totalWeight += stackClone.entries[k].grid_entry.relev;
//     }
//
//     stackClone.relev = Math.min(roundTo(totalWeight, 8), 1);
//     return stackClone;
// }

function rebalance_new(query, stack) {
    let adjustedRelevance = 0;
    adjustedRelevance = stack.relev + (-0.5 / stack.entries.length) + 0.5;

    const length = stack.entries.length;
    for (let k = 0; k < length; k++) {
        stack.entries[k].grid_entry.relev = adjustedRelevance / length;
    }
    stack.relev = Math.min(roundTo(adjustedRelevance, 8), 1);
    return stack;
}


function preparePhrasematches(phrasematchResults) {
    let id = 0;
    const flattened = [];
    let maxZoom = 0;

    for (let i = 0; i < phrasematchResults.length; i++) {
        for (let j = 0; j < phrasematchResults[i].length; j++) {
            const phrasematch = phrasematchResults[i][j];
            phrasematch.id = id;

            if (phrasematch.zoom > maxZoom) maxZoom = phrasematch.zoom;

            flattened[id] = phrasematch;
            id++;
        }
    }

    return {
        flattenedPhrasematches: flattened,
        maxZoom: maxZoom
    };
}

/**
 * Spatialmatch features of a stacks that could be stacked together spatially
 *
 * @constructor
 * @param {Object} cacheSpatialmatch - TODO
 * @param {Object} stackByIdx - TODO
 * @param {Object} addressDataByIdx - TODO
 * @param {Boolean} partialNumber - TODO
 */
function Spatialmatch(cacheSpatialmatch, flattenedPhrasematches) {
    this.relev = cacheSpatialmatch.relev;
    this.address = null;
    this.partialNumber = false;
    this.covers = [];
    for (let i = 0; i < cacheSpatialmatch.entries.length; i++) {
        const cacheCover = cacheSpatialmatch.entries[i];
        const phrasematch = flattenedPhrasematches[cacheCover.phrasematch_id];
        this.covers.push(new Cover(cacheCover, phrasematch));

        // just do these once, for the sake of determinism
        if (!this.address) {
            if (phrasematch.address) this.address = phrasematch.address;
        }
        if (!this.partialNumber) {
            if (phrasematch.partialNumber) this.partialNumber = phrasematch.partialNumber;
        }
    }
    this.scoredist = this.covers[0].scoredist;
    // this line artificially boosts scoredist for nearby partial-number matches
    // from address indexes, which may not have an informative score that would
    // otherwise allow them to be surfaced; the specific multiplier was determined
    // by trial and error and ideally, we'd come up with a way to tackle this in
    // a less hacky way
    if (this.partialNumber) this.scoredist *= 300;
}

/**
 * Tile Cover of a phrasematch
 *
 * @constructor
 * @param {Object} cacheCover - TODO
 * @param {Object} phrasematch - TODO
 */
function Cover(cacheCover, phrasematch) {
    this.x = cacheCover.grid_entry.x;
    this.y = cacheCover.grid_entry.y;
    this.relev = cacheCover.grid_entry.relev;
    this.id = cacheCover.grid_entry.id;
    this.idx = cacheCover.idx;
    this.tmpid = cacheCover.tmp_id;
    this.distance = cacheCover.distance;
    this.score = termops.decode3BitLogScale(cacheCover.grid_entry.score, phrasematch.scorefactor);
    this.scoredist = cacheCover.scoredist > 7 ? (phrasematch.scorefactor / 7) * cacheCover.scoredist : termops.decode3BitLogScale(cacheCover.scoredist, Math.max(phrasematch.scorefactor, 1.01));
    this.scorefactor = phrasematch.scorefactor;
    this.matches_language = cacheCover.matches_language;
    this.source_phrase_hash = cacheCover.grid_entry.source_phrase_hash;
    this.prefix = phrasematch.prefix;

    this.mask = phrasematch.mask;
    this.text = phrasematch.subquery.join(' ');
    this.zoom = phrasematch.zoom;
}

/**
 * sortByRelev spatialmatches by relevance
 *
 * @param {object} a - Spatialmatch
 * @param {object} b - Spatialmatch
 * @returns {number} sort order
 */
function sortByRelev(a, b) {
    return (b.relev - a.relev) ||
        (b.scoredist - a.scoredist) ||
        (a.covers[0].idx - b.covers[0].idx) ||
        (b.address ? 1 : 0) - (a.address ? 1 : 0);
}
